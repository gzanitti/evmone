// Code generated by {{ .Meta.Name }}. DO NOT EDIT.

// Computes z = 1/x (mod p) and returns it.
uint256 inv(const ModArith<uint256>& s, const uint256& x) noexcept {
    uint256 z;
    // Inversion computation is derived from the addition chain:
    //
    {{- range lines (format .Script) }}
    // {{ . }}
    {{- end }}
    //
    // Operations: {{ .Ops.Doubles }} squares {{ .Ops.Adds }} multiplies
    //
    // Generated by {{ .Meta.Module }} {{ .Meta.ReleaseTag }}.

    // Allocate Temporaries.
    {{- range .Program.Temporaries }}
    uint256 {{ . }};
    {{- end -}}

    {{ range $i := .Program.Instructions }}
    // {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.Chain $i.Output.Index) }}
    {{- with add $i.Op }}
    {{ $i.Output }} = s.mul({{ .X }}, {{ .Y }});
    {{ end -}}

    {{- with double $i.Op }}
    {{ $i.Output }} = s.mul({{ .X }}, {{ .X }});
    {{ end -}}

    {{- with shift $i.Op -}}
    {{- $first := 0 -}}
    {{- if ne $i.Output.Identifier .X.Identifier }}
    {{ $i.Output }} = s.mul({{ .X }}, {{ .X }});
    {{- $first = 1 -}}
    {{- end }}
    for (int i = {{ $first }}; i < {{ .S }}; ++i)
        {{ $i.Output }} = s.mul({{ $i.Output }}, {{ $i.Output }});
    {{ end -}}
    {{- end }}
    return z;
}
